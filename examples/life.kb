-- @todo: use an object.
ENV.mk_board := fn(w, h)
    let values = []
    var i = 0
    while i < w*h:
        values[i] := 0
        i += 1
    end
    return values
end

ENV.board_print := fn(board, w, h)
    var y = 0
    while y < h:
        var x = 0
        while x < w:
            print(if board[y*w + x] > 0: "#" else "." end)
            x += 1
        end
        println("")

        y += 1
    end

    println("")
end

ENV.board_get := fn(board, w, h, x, y)
    if   x <  0: x += w
    elif x >= w: x -= w end

    if   y <  0: y += h
    elif y >= h: y -= h end

    return board[y*w + x]
end

ENV.board_step := fn(board, w, h)
    let new_board = mk_board(w, h);

    var y = 0
    while y < h:
        var x = 0
        while x < w:
            let neighbors =
                  board_get(board, w, h, x - 1, y - 1)
                + board_get(board, w, h, x    , y - 1)
                + board_get(board, w, h, x + 1, y - 1)
                + board_get(board, w, h, x - 1, y    )
                + board_get(board, w, h, x + 1, y    )
                + board_get(board, w, h, x - 1, y + 1)
                + board_get(board, w, h, x    , y + 1)
                + board_get(board, w, h, x + 1, y + 1)

            let cell = board[y*w + x]
            if neighbors == 3:
                new_board[y*w + x] = 1
            elif cell == 1:
                if neighbors == 2:
                    new_board[y*w + x] = 1
                end
            end

            x += 1
        end

        y += 1
    end

    return new_board
end

ENV.sleep := fn()
    var i = 0
    while i < 500000:
        i += 1
    end
end


var w = 10
var h = 10
var board = mk_board(w, h)

board[3*w + 1] = 1
board[3*w + 2] = 1
board[3*w + 3] = 1
board[2*w + 3] = 1
board[1*w + 2] = 1

var i = 0
while i < 20:
    board_print(board, w, h)
    board = board_step(board, w, h)
    sleep()
    i += 1
end

