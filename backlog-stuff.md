- todo:
    - revise mouse events.
        - bubbling.
        - multiple hovered widgets, one hot widget.
        - oh, events are propagated to ancestors only!
            - and if you have a child overlapping a sibling, the sibling doesn't get the event.
            - that's how overlays prevent `:hover` on the content beneath them.
        - so let's do dom style hovering.
            - parent is hovered, when child is hovered.
            - children are tested in reverse, stop on first hit.
            - last widget in hover list is the "hot" widget.
            - pointer events on by default.
            - events bubble to parents, unless propagation is stopped.
            - events have flag, whether current widget was target of event.
            - things like click are also propagated, even for buttons, but event handlers can of course stop propagation for specific buttons. common case util: `clicked_directly: clicked and is_target`.
            - consider making event (data) an enum.
                - be more official about "one event at a time".
                - otherwise stop_propagation could stop multiple events.
                - and it's just generally more intuitive.
        - how to make buttons show, when line is hovered?
            - could duplicate state.
            - could have `hidden` prop and set once have line events.
            - could have `widget_box_ex`, which passes a `None` event to the closure (with the hover state).
    - windows:
        - clipping.
        - scrolling.
        - code view as window with scrolling (optional, otherwise grow).
    - sub-tree skipping:
        - event mask.
        - pass `skip: bool` to widget_box.
        - also sub-tree `no_skip` override -> can set on root node for full update, ignores local caches. useful for stuff like theme, so you don't need fine grained dependency tracking.
        - gui skips child fn if there are no events in the sub-tree.
        - key must not be counter.
        - compute render children in intrinsic pass.
        - not sure this is actually all that useful.
            - things like decorations change pretty often, and they're somewhat expensive to cache (cause you'd need to diff the decos for each line).
            - so virtualization would be much more effective.
            - though could still help with layout & allocation overhead.
    - ui stuff:
        - box-sizing.
        - clip mouse, unless captured.
        - hit test on mouse up (cause capture may have prevented hover).
        - clip.
        - event bubbling.
        - change style props after widget creation (active highlight).
        - text background fill.
            - text widgets in text layout's render children list.
            - hit_test_range in `draw` before drawing text layout.
        - inline widgets.
            - text layout inline objects & layout function (store glyph advances).
            - text layout widget render children list (layout inline widgets first).
        - flex grow.
        - flex justify gaps.
        - cache calls to layout_pass: store given_size on widget (clear in intrinsic pass).
        - grid layout.
        - overlays?
            - for drop downs, tool tips, etc.
            - are like regular children (in some parent down the tree).
            - but are don't affect layout,
            - positioned relative to some other widget,
            - drawn on top of all other widgets.
        - text layout word wrapping.

- todo: debug info.
    - node info for pc.
        - own value vs aliases.
        - store own values (opt) & node for each op.
        - well, own value is always node id.
            - so replace source info with node id.
            - then have flag for "is value": if true, the instr produces the value of its node id.
    - control flow info.
        - basic blocks + semantic annotations.
            - loop header/body.
            - if then/else branch.
            - do block body.
            - function body.
    - value query.
        - call stack.
        - getting register values from other stack frames.
        - extensible stack for host functions -> regs are the "slots".


- general backlog:
    - module state.
    - inout params.
        - can't pass globals.
    - tuples.
        - destructuring.
        - tuple ret.
    - optional args & varargs.
    - del.
    - table -> map.
    - usable host api.
    - proper gc & memory allocation.
    - closures.
    - kbtf.
        - wasm-like transfer format.
        - unlimited registers (but limit to 127 for now).
        - later: typed registers.
            - easy to validate.
            - can be used for unchecked operations.
        - vm optimizations like inline caches are not exposed.
        - "close captures" instruction.

- compiler backlog:
    - ast child visitors.
    - compile:
        - assert cfg has no critical edges.
    - validation:
        - phi maps & stmt lists uniquely owned.
        - return error instead of panicking.
    - trace logging:
        - for debugging & giving insight into what the compiler does.
    - debug info:
        - accurate source ranges.
        - local mapping.
    - no-elim stmt flag.
    - default return is empty tuple.
    - tuple return optimization.
    - parser:
        - token array.
        - remove eof token.
    - features:
        - numbers.
        - tables.
        - break, continue, return.
        - optional chaining.
    - impl-opt:
        - function::gc.
        - typed bb/stmt bit sets.
        - phi2 & call0-4.
        - track phi begin/end on bbs.
        - cssa: update terminator args.
    - tests.


- vm backlog:
    - booleans.
    - integers.
    - or_else.
    - get_field.
    - function env capture.
    - impl-opt:
        - 16 byte align `Value`.
        - generic ops: inline(always).
        - stack & instruction "pointers".
        - hash slot prediction.
        - hidden classes?
    - tests.

- low priority backlog:
    - `IfBlock` -> `ValueBlock` use for functions?
    - `_` for discarding values.
    - and_then: opposite of `??`. what operator?
        - maybe `&&` for and_then, `||` for or_else.
    - cssa: replace terminator args.
    - repl: support multiple stmts.
        - print value of all of them.

- ideas:
    - reverse debugging:
        - start with snapshots + outputs of external functions.
        - perf wise, that would be a bit like a stop-the-world gc - not ideal, but good enough, maybe.
        - cancel snapshot if there's a non-serializable host function in the call stack.
    - resumable host code:
        - enables pausing code anywhere -> preemptive multi-tasking.
        - maybe using async for ergonomics.
            - issue: future captures `&mut Vm`.
        - serializable state machine would be better.
            - no unsafe required.
            - serializable.
        - also keep non-state-machine host functions, as they're faster (require no allocation for state).
        - related: host closures.
    - fast strcmp: ptr_eq first.
    - jump tables.
    - runtime, cross-module optimizations:
        - eg: inlining.
        - can always flush the optimizations, if module is reloaded or exported function is changed.
    - typed user data.
    - instanceof instruction.
    - coverage instruction.
        - with inline counter.
    - freezing & read-only refs.
    - get/set object properties.
    - `do` block constraints:
        - restrict variable "capture": `[&a, &mut b]`.
        - if use that, can't return from outer function either. maybe.


