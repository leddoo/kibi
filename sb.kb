axiom ax_sorry.{t}<T: Sort(t)>: T
axiom ax_uninit.{t}<T: Sort(t)>: T
axiom ax_unreach.{t}<T: Sort(t)>: T


inductive False {}

inductive True { trivial }


inductive Eq.{t} <T: Sort(t)> (a: T) : Pi(b: T) -> Prop {
    refl: Eq(a);
}

def congr_arg.{a, b} <A: Sort(a), B: Sort(b), a1 a2: A> (f: A -> B)
    : a1 = a2 -> f(a1) = f(a2)
    := lam heq => Eq::rec(Eq::refl(), heq)


inductive Unit { mk }


inductive Bool {
    false;
    true;
}

def Bool::No_Confusion.{p} (P: Sort(p), a b: Bool): Sort(p) :=
    Bool::rec(
        Bool::rec(P -> P, P, a),
        Bool::rec(P, P -> P, a),
        b)

def Bool::no_confusion.{p} <P: Sort(p), a b: Bool>: a = b -> Bool::No_Confusion(P, a, b) :=
    lam h => Eq::rec(Bool::rec(lam p => p, lam p => p, a), h)

def ite <T: Type> (cond: Bool) (on_true: T) (on_false: T): T
    := Bool::rec(on_false, on_true, cond)


trait inductive Decidable (P: Prop) {
    is_false (h: P -> False);
    is_true  (h: P);
}

def dite (cond: Prop) <h: Decidable(cond)>
    <T: Type> (on_true: cond -> T) (on_false: (cond -> False) -> T)
    : T
    := Decidable::rec(on_false, on_true, h)

def Decidable::to_bool<P: Prop>(self: Decidable(P)): Bool :=
    Decidable::rec(lam _ => Bool::false, lam _ => Bool::true, self)



inductive Nat {
    zero;
    succ (of: Nat);
}

def Nat::No_Confusion.{p} (P: Sort(p), a b: Nat): Sort(p) :=
    Nat::rec(
        Nat::rec(P -> P, lam _ _ => P, a),
        lam b _ => Nat::rec(P, lam a _ => (Eq(a, b) -> P) -> P, a),
        b)

def Nat::no_confusion.{p} <P: Sort(p), a b: Nat>: a = b -> Nat::No_Confusion(P, a, b) :=
    lam h => Eq::rec(Nat::rec(lam p => p, lam _ _ => lam p => p(Eq::refl()), a), h)


def Nat::succ_inj <a b: Nat>
    : Nat::succ(a) = Nat::succ(b) -> a = b
    := lam h => Nat::no_confusion(h, lam eq => eq)


-- @todo: named impls.
def Nat::dec_eq (a b: Nat): Decidable(Eq(a, b)) :=
    Nat::rec(
        lam b => Nat::rec(
            Decidable::is_true(Eq::refl()),
            lam _ _ => Decidable::is_false(Nat::no_confusion()),
            b),
        lam a rec b => Nat::rec(
            Decidable::is_false(Nat::no_confusion()),
            lam b _ => Decidable::rec(
                lam h => Decidable::is_false(lam heq => h(Nat::succ_inj(heq))),
                lam h => Decidable::is_true(congr_arg(_, h)),
                rec(b)),
            b),
        a, b)

impl<a b: Nat>: Decidable(Eq(a, b)) := Nat::dec_eq(a, b)



trait inductive Add (A B: Type): Sort(2) {
    mk (R: Type) (add: A -> B -> R)
}

def Add::R <A B: Type> (self: Add(A, B)): Type :=
    Add::rec(lam R add => R, self)

def Add::add <A B: Type, self: Add(A, B)>: A -> B -> Add::R(self) :=
    Add::rec(lam R add => add, self)



def Nat::add (a b: Nat): Nat :=
    Nat::rec(a, lam _ r => Nat::succ(r), b)

impl: Add(Nat, Nat) :=
    Add::mk(Nat, Nat::add)



inductive Pair(A B: Type) {
    mk (fst: A, snd: B)
}

def Pair::fst<A B: Type>(self: Pair(A, B)): A := Pair::rec(lam fst snd => fst, self)
def Pair::snd<A B: Type>(self: Pair(A, B)): B := Pair::rec(lam fst snd => snd, self)


inductive Option(T: Type) {
    none;
    some (value: T);
}

inductive List(T: Type) {
    nil;
    cons (head: T, tail: List);
}

def List::find<T: Type>(self: List(T), p: T -> Bool): Option(T) :=
    List::rec(
        Option::none(),
        lam head _ rec => ite(p(head), Option::some(head), rec), self)


inductive Result(T: Type, E: Type) {
    ok  (result: T);
    err (error: E);
}

def Result::and_then<T1 T2 E: Type>(self: Result(T1, E), f: T1 -> Result(T2, E)): Result(T2, E) :=
    Result::rec(
        lam r => f(r),
        lam e => Result::err(e),
        self)

def Option::ok_or<T E: Type>(self: Option(T), e: E): Result(T, E) :=
    Option::rec(
        Result::err(e),
        lam r => Result::ok(r),
        self)



-- stacked borrows:

def Tag := Nat

inductive Tag_Kind {
    exclusive;
    shared_mut;
    shared;
    const;
}

inductive Entry {
    mk (tag: Tag, kind: Tag_Kind);
}

def Entry::tag(self: Entry): Tag := Entry::rec(lam tag kind => tag, self)
def Entry::kind(self: Entry): Tag_Kind := Entry::rec(lam tag kind => kind, self)

inductive Stack {
    mk (entries: List(Entry), next_tag: Tag)
}

def Stack::new := Stack::mk(List::cons(Entry::mk(0, Tag_Kind::exclusive), List::nil()), 1)

def Stack::entries(self: Stack): List(Entry) := Stack::rec(lam entries next_tag => entries, self)
def Stack::next_tag(self: Stack): Nat := Stack::rec(lam entries next_tag => next_tag, self)


inductive Error {
    not_in_stack (tag: Tag);
    cant_derive_from (parent: Entry);
    cant_write (entry: Entry);
    cant_write_inner (entry: Entry);
}


def Stack::push(self: Stack, kind: Tag_Kind, head: Entry, tail: List(Entry)): Pair(Stack, Tag) :=
    Pair::mk(
        Stack::mk(
            List::cons(Entry::mk(Stack::next_tag(self), kind), List::cons(head, tail)),
            Nat::succ(Stack::next_tag(self))),
        Stack::next_tag(self))

def Stack::use(self: Stack, head: Entry, tail: List(Entry)): Pair(Stack, Tag) :=
    Pair::mk(
        Stack::mk(
            List::cons(head, tail),
            Stack::next_tag(self)),
        Entry::tag(head))


def Stack::new_exclusive(self: Stack, parent: Tag): Result(Pair(Stack, Tag), Error) :=
    List::rec(
        Result::err(Error::not_in_stack(parent)),
        lam e tail rec =>
            dite(Eq(Entry::tag(e), parent),
                lam _ => Tag_Kind::rec(
                    -- exclusive
                    Result::ok(Stack::push(self, Tag_Kind::exclusive, e, tail)),
                    -- shared_mut
                    Result::ok(Stack::push(self, Tag_Kind::exclusive, e, tail)),
                    -- shared
                    Result::err(Error::cant_derive_from(e)),
                    -- const
                    Result::err(Error::cant_derive_from(e)),
                    Entry::kind(e)),
                lam _ => rec),
        Stack::entries(self))


def Stack::new_shared_mut(self: Stack, parent: Tag): Result(Pair(Stack, Tag), Error) :=
    List::rec(
        Result::err(Error::not_in_stack(parent)),
        lam e tail rec =>
            dite(Eq(Entry::tag(e), parent),
                lam _ => Tag_Kind::rec(
                    -- exclusive
                    Result::ok(Stack::push(self, Tag_Kind::shared_mut, e, tail)),
                    -- shared_mut
                    Result::ok(Stack::use(self, e, tail)),
                    -- shared
                    Result::err(Error::cant_derive_from(e)),
                    -- const
                    Result::err(Error::cant_derive_from(e)),
                    Entry::kind(e)),
                lam _ => rec),
        Stack::entries(self))


def Stack::new_shared(self: Stack, parent: Tag): Result(Pair(Stack, Tag), Error) :=
    List::rec(
        Result::err(Error::not_in_stack(parent)),
        lam e tail rec =>
            dite(Eq(Entry::tag(e), parent),
                lam _ => Tag_Kind::rec(
                    -- exclusive
                    Result::ok(Stack::push(self, Tag_Kind::shared, e, tail)),
                    -- shared_mut
                    Result::ok(Stack::push(self, Tag_Kind::shared, e, tail)),
                    -- shared
                    Result::ok(Stack::use(self, e, tail)),
                    -- const
                    Result::err(Error::cant_derive_from(e)), -- @todo: flag to allow.
                    Entry::kind(e)),
                lam _ => rec),
        Stack::entries(self))


def Stack::new_const(self: Stack, parent: Tag): Result(Pair(Stack, Tag), Error) :=
    List::rec(
        Result::err(Error::not_in_stack(parent)),
        lam e tail rec =>
            dite(Eq(Entry::tag(e), parent),
                lam _ => Tag_Kind::rec(
                    -- exclusive
                    Result::ok(Stack::push(self, Tag_Kind::const, e, tail)),
                    -- shared_mut
                    Result::ok(Stack::push(self, Tag_Kind::const, e, tail)),
                    -- shared
                    Result::err(Error::cant_derive_from(e)), -- @todo: flag to allow.
                    -- const
                    Result::ok(Stack::use(self, e, tail)),
                    Entry::kind(e)),
                lam _ => rec),
        Stack::entries(self))


def Stack::read(self: Stack, tag: Tag): Result(Stack, Error) :=
    List::rec(
        Result::err(Error::not_in_stack(tag)),
        lam e tail rec =>
            dite(Eq(Entry::tag(e), tag),
                lam _ =>
                    -- read is always ok.
                    Result::ok(Pair::fst(Stack::use(self, e, tail))),
                lam _ => rec),
        Stack::entries(self))


def Stack::write(self: Stack, tag: Tag): Result(Stack, Error) :=
    List::rec(
        Result::err(Error::not_in_stack(tag)),
        lam e tail rec =>
            dite(Eq(Entry::tag(e), tag),
                lam _ => Tag_Kind::rec(
                    -- exclusive
                    Result::ok(Pair::fst(Stack::use(self, e, tail))),
                    -- shared_mut
                    Result::ok(Pair::fst(Stack::use(self, e, tail))),
                    -- shared
                    Result::err(Error::cant_write(e)),
                    -- const
                    Result::err(Error::cant_write(e)),
                    Entry::kind(e)),
                lam _ => rec),
        Stack::entries(self))


def Stack::write_inner(self: Stack, tag: Tag): Result(Stack, Error) :=
    List::rec(
        Result::err(Error::not_in_stack(tag)),
        lam e tail rec =>
            dite(Eq(Entry::tag(e), tag),
                lam _ => Tag_Kind::rec(
                    -- exclusive
                    Result::ok(Pair::fst(Stack::use(self, e, tail))),
                    -- shared_mut
                    Result::ok(Pair::fst(Stack::use(self, e, tail))),
                    -- shared
                    Result::ok(Pair::fst(Stack::use(self, e, tail))),
                    -- const
                    Result::err(Error::cant_write_inner(e)),
                    Entry::kind(e)),
                lam _ => rec),
        Stack::entries(self))


def Stack::retag(self: Stack, tag: Tag): Result(Stack, Error) :=
    Stack::read(self, tag)


-- example:
--  var v = 42
--  let r1 = &mut v
--  let r2 = &mut *r1
--  *r1 = 69
--  *r2

reduce Result::and_then(Result::and_then(Result::and_then(Result::and_then(Result::ok(Stack::new()),
    lam s => Stack::new_exclusive(s, 0)),
    lam r => Stack::new_exclusive(Pair::fst(r), 1)),
    lam r => Stack::write(Pair::fst(r), 1)),
    lam s => Stack::read(s, 2))


-- example:
--  fn foo(r: &I32, f: is FnOnce()) {
--      let v = *r
--      f()
--      return v  -- want to assert `r` live -> delay read
--  }
--
--  var v = 42
--  let p = &mut v as *mut i32
--  foo(&*p, fn() { *p = 69 })  -- refs used before & after
--  print(v)

reduce Result::and_then(Result::and_then(Result::and_then(Result::and_then(Result::and_then(Result::and_then(Result::and_then(Result::ok(Stack::new()),
    lam r => Stack::new_exclusive(r, 0)),               -- &mut v
    lam r => Stack::new_shared_mut(Pair::fst(r), 1)),   -- as *mut i32
    lam r => Stack::new_shared(Pair::fst(r), 2)),       -- &*p
    lam r => Stack::read(Pair::fst(r), 3)),             -- foo: *r
    lam r => Stack::write(r, 2)),                       -- fn: *p = 69
    lam r => Stack::retag(r, 3)),                       -- after foo: validate &*p
    lam r => Stack::read(r, 0))                         -- print(v)



--  var v := 42
--  let r1 := &mut v
--  let r2 := &mut *r1
--  *r1 := 69
--  *r2
--
-- locals:
--  v: I32
--  r1: Ref('r1, .mut, I32)
--  r2: Ref('r2, .mut, I32)
--
-- ir:
--  let v := -- create ref for local "v"
--  let _ := Ref::write(v, I32::of_nat(42))
--  let r1 := -- create ref from `v`
--  let r2 := -- create ref from `r2`
--  let _ := Ref::write(r1, I32::of_nat(69))
--  let _ := Ref::read(r2)
--  ()


axiom Region: Type

axiom Region::local(id: Nat): Region
axiom Region::array_field(array: Region, index: Nat): Region


inductive Ref_Kind {
    mut;
    shr;
    const;
}

inductive Ref(r: Region, kind: Ref_Kind, T: Type) {
    mk (tag: Tag, addr: Nat)
    -- todo: the tag needs to be opaque, so we can't derive equality.
    -- todo: trait for metadata.
    -- todo: `addr: NonZeroUsize`.
}

def Ref::addr<r: Region, kind: Ref_Kind, T: Type>(self: Ref(r, kind, T)): Nat :=
    Ref::rec(lam tag addr => addr, self)

axiom Ref::from_local(id: Nat, kind: Ref_Kind, T: Type): Ref(Region::local(id), kind, T)
axiom Ref::from_ref<r: Region, kind1: Ref_Kind, T: Type>(ref: Ref(r, kind1, T), kind2: Ref_Kind): Ref(r, kind2, T)

axiom Ref::cast_region<r1: Region, kind: Ref_Kind, T: Type>(ref: Ref(r1, kind, T), r2: Region): Ref(r2, kind, T)

axiom Ref::read<r: Region, kind: Ref_Kind, T: Type>(ref: Ref(r, kind, T)): T
axiom Ref::write<r: Region, T: Type>(ref: Ref(r, Ref_Kind::mut, T), value: T): Ref::read(ref) = value


-- thinking model this as a `&mut` in SB.
-- for `allocate`, have an `allow_from_shared` flag for `new_exclusive`.
inductive Unique<A: Type>(alloc: A, T: Type) {
    mk (tag: Tag, addr: Nat)
}

def Unique::addr<A: Type, alloc: A, T: Type>(self: Unique(alloc, T)): Nat :=
    Unique::rec(lam tag addr => addr, self)

-- we prob wanna make this & `Maybe_Init` opaque.
inductive Maybe_Free(T: Type) {
    mk (inner: T)
}

-- should prob be a `Type`, cause `Prop`s will be copy.
axiom Is_Free<T: Type>(slot: Maybe_Free(T)): Prop

-- this should probably return `Unique(Maybe_Init(T))`
axiom allocate<r: Region, A: Type, T: Type>(
    -- `where A <: r` or something
    -- basically, we wanna use `A` for the region,
    -- so you can use `Global_Alloc` without needing a region
    -- *and* the instance.
    -- tbf, i'd prefer it if `Unique` had a region.
    -- that would make it more flexible for "stack based allocation", i think
    -- but `Box<r, A is r, T>` sucks.
    alloc: A,
    slot: Ref(r, Ref_Kind::shr, Maybe_Free(T)),
    is_free: Is_Free(Ref::read(slot)))
    : Unique(alloc, T)

-- though maybe we could have `Unique(r, T)`
-- and `Allocation(alloc, T)`, which uses some kind of self-reference.
-- well, then, `Box` could use that same trick.
-- basically, we want the `reachable`/`derived`/`sdom` region.
-- that would be a lot better:
-- allocate: (slot: &'r Maybe_Free(T)): Is_Free(*slot) -> Unique('r, T)
-- free:     (slot: &'r Maybe_Free(T)): Unique('r, T) -> Is_Free(*slot)
-- plus the `ptr_eq` thing for free.
-- i guess, we don't need the `'r`s to unify.
-- something something, covariance.
-- the idea is that reachable is fine, cause the base is a part of the type,
-- so mutation is impossible by tt.
-- that's an issue though. ig we want `reachable` and `const_reachable`.
-- where `reachable` allows interior mutation. which would be fine, cause
-- you can't free something with `&shr` unless you have a `Unique`.
-- and if it's something borrowed, the type already needs to make sure that
-- the borrowed thing lives long enough.
-- would be nice to get more formal about this, though not exactly sure how.
-- hmm, we do need the allocator as a part of the type: mimalloc style address truncation.
-- or at least an allocator specific `Prop`. yeah, mimalloc is prob the end boss.
-- cyclic references and all that.
-- ig that prop should borrow the block as shared? unique live -> prop live.
-- brck interpreter would do some dyn stuff to validate?
-- note: reference based `Unique` + allocator aware `Allocation` seems like the way to go.
-- `Allocation` would store the invariants. for `&dyn Alloc`, bori will need some special
-- support, i suppose.

axiom free<r: Region, A: Type, alloc: A, T: Type>(
    ptr: Unique(alloc, T),
    slot: Ref(r, Ref_Kind::shr, Maybe_Free(T)),
    ptr_eq: Eq(Unique::addr(ptr), Ref::addr(slot)))
    : Is_Free(Ref::read(slot))

axiom leak<r: Region, A: Type, alloc: A, T: Type>(
    -- `where A <: r`
    ptr: Unique(alloc, T))
    : Ref(r, Ref_Kind::mut, T)


inductive Box<A: Type, T: Type> {
    mk (alloc: A, ptr: Unique(alloc, T))
}


def I32 := Nat -- temp

def foo :=
    let v  := Ref::from_local(0, Ref_Kind::mut, I32) in
    let r1 := Ref::from_ref(v, Ref_Kind::mut) in
    let r2 := Ref::from_ref(r1, Ref_Kind::mut) in
    let _  := Ref::write(r1, 69) in
    let _  := Ref::read(r2) in
    Unit::mk()


def ass_test: Nat := do {
    var x;
    x;
    x := 1;
    x;
    x := x + 1;
    x;
    do { x := 3 };
    x;

    x := if Bool::false { 6 } elif Bool::true { 9 } else { 7 };
    x;

    if Bool::true {
        x := x + 2;
    }
    elif Bool::false {
        Unit::mk
    }
    else {
        let y := 6;
        x := y + 1;
    };
    break x;
}


def brk_1: Nat := do {
    break 42;
}
reduce brk_1

def brk_2: Nat := do {
    if Bool::true {
        break 42;
    };
    break 69;
}
reduce brk_2

def brk_3: Nat := do {
    break do { break 42; };
}
reduce brk_3

def brk_4: Nat := do {
    if Bool::true {
        break 42;
    }
    else {
        break 69;
    };
}
reduce brk_4


def brck_basic := do {
    var v  := 42;
    let r1 := &mut v;
    let r2 := &mut *r1;
    *r1 := 69;
    *r2;
}


