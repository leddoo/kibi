
- next steps:
    - basic crates.
        - single module.
        - static name binding, unless functions are declared as `var fn`.
        - basic type checking.
            - and `var` validation.
        - env:
            - there's one env per module (so one env total for now).
            - functions are tagged with their module, this can't be changed.
            - an env isn't quite a map, but close. it prevents writes to imported & non-var symbols.
        - kbtf.
    - debug info.
        - better source info (eg: `ast::Block::source`, `ast::Op1::op_source`).
        - variable mapping.
        - better runtime errors.
    - proper maps.
    - nominal structs, enums & traits.
        - typeid.
    - macros, modules, multithreading.
        - yeah, kinda unnecessary atm.
        - but getting these 3 to work together later sounds like a nightmare.
    - error handling:
        - try operator.
        - pcall.
    - `Gc` type, `new`.
        - implicit deref/inout with methods.
        - but pass without deref.
        - so `&*` to inout boxed value?
        - compiler could do implicit stuff if has types.
        - fix gc.
    - debugging.
    - ui.


- todo: basic crates:
    - compiler:
        - ast:
            - item.
            - module.
        - basic sema:
            - assign `ItemId`s and `NodeId`s.
            - basic type checking.
                - "sema info" index vec over node ids.
                - no type table yet.
                - we basically just have `Any` and `List<Any>` :D
                - well, there's also `Float`, `String`, tuples, fns.
                - and perhaps type variables.
                - we'll just ignore/collect type errors for now.
            - stuff:
                - handle anon functions.
                - names of fn expressions are only visible inside the function for recursion.
                - `var` items are ordered.
                - local decls can shadow item decls, even for items in the current function.
                - linear source map seems useful (eventually).
                    - don't need extra "file id".
                    - can store line info, so source ranges are just byte offsets.
                    - macro output can be serialized into that.
                    - though we do want errors & completions in macro inputs at source level.
                        - for debugging, we want the generated code to be available.
                        - the inline view thing can still help, but not for code that's actually generated programmatically.
        - crate format (kbtf).
        - compile_crate api for now. can make more granular later.
    - vm:
        - load crate.
            - impl static binding:
                - can't bind to other crates or host for now.
            - runs the code.
            - multiple loaded crates.
                - each with their own env.


- prev:
    - tuples.
        - destructuring.
        - tuple ret.
    - barely usable host api.
    - kbtf & validation.
    - trace logging.

- decisions to make:
    - kwargs?
    - use atomic for interrupt?
        - really not executed that often.
        - definitely not ub.

- general backlog:
    - inout params.
        - can't pass globals.
    - optional args & varargs.
    - del.
    - table -> map.
    - usable host api.
    - proper gc & memory allocation.
    - closures.
    - kbtf.
        - wasm-like transfer format.
        - unlimited registers (but limit to 127 for now).
        - later: typed registers.
            - easy to validate.
            - can be used for unchecked operations.
        - vm optimizations like inline caches are not exposed.
        - "close captures" instruction.

- compiler backlog:
    - compile:
        - assert cfg has no critical edges.
    - validation:
        - phi maps & stmt lists uniquely owned.
        - return error instead of panicking.
    - trace logging:
        - for debugging & giving insight into what the compiler does.
    - debug info:
        - accurate source ranges.
        - local mapping.
    - no-elim stmt flag.
    - default return is empty tuple.
    - tuple return optimization.
    - parser:
        - token array.
        - remove eof token.
    - features:
        - numbers.
        - tables.
        - break, continue, return.
        - optional chaining.
    - impl-opt:
        - function::gc.
        - typed bb/stmt bit sets.
        - phi2 & call0-4.
        - track phi begin/end on bbs.
        - cssa: update terminator args.
    - tests.


- vm backlog:
    - booleans.
    - integers.
    - or_else.
    - get_field.
    - function env capture.
    - impl-opt:
        - 16 byte align `Value`.
        - generic ops: inline(always).
        - stack & instruction "pointers".
        - hash slot prediction.
        - hidden classes?
    - tests.

- low priority backlog:
    - `IfBlock` -> `ValueBlock` use for functions?
    - `_` for discarding values.
    - and_then: opposite of `??`. what operator?
        - maybe `&&` for and_then, `||` for or_else.
    - cssa: replace terminator args.

- ideas:
    - reverse debugging:
        - start with snapshots + outputs of external functions.
        - perf wise, that would be a bit like a stop-the-world gc - not ideal, but good enough, maybe.
        - cancel snapshot if there's a non-serializable host function in the call stack.
    - resumable host code:
        - enables pausing code anywhere -> preemptive multi-tasking.
        - maybe using async for ergonomics.
            - issue: future captures `&mut Vm`.
        - serializable state machine would be better.
            - no unsafe required.
            - serializable.
        - also keep non-state-machine host functions, as they're faster (require no allocation for state).
        - related: host closures.
    - fast strcmp: ptr_eq first.
    - jump tables.
    - runtime, cross-module optimizations:
        - eg: inlining.
        - can always flush the optimizations, if module is reloaded or exported function is changed.
    - typed user data.
    - instanceof instruction.
    - coverage instruction.
        - with inline counter.
    - freezing & read-only refs.
    - get/set object properties.
    - `do` block constraints:
        - restrict variable "capture": `[&a, &mut b]`.
        - if use that, can't return from outer function either. maybe.

