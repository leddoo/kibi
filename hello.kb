axiom ax_sorry.{t}<T: Sort(t)>: T
axiom ax_uninit.{t}<T: Sort(t)>: T
axiom ax_unreach.{t}<T: Sort(t)>: T
axiom ax_error.{t}<T: Sort(t)>: T


inductive False: Prop {
}

inductive True: Prop {
    trivial;
}

inductive Nat {
    zero: Nat;
    succ (of: Nat);
}

inductive Eq.{t} <T: Sort(t)> (a: T) : Pi(b: T) -> Prop {
    refl: Eq(a);
}


inductive Array (T: Type) : Pi(n: Nat) -> Type {
    nil: Array(0);
    cons <n: Nat> (head: T, tail: Array(n)): Array(Nat::succ(n));
}


inductive Exists.{t} (T: Sort(t), P: T -> Prop): Prop {
    mk (value: T, h: P(value));
}

inductive Subtype.{t} <T: Sort(t)> (P: T -> Prop): Sort(max(1, t)) {
    mk (value: T, h: P(value));
}


trait inductive Add (A B: Type): Sort(2) {
    mk (R: Type) (add: A -> B -> R);
}

def Add::R <A B: Type> (self: Add(A, B)): Type :=
    Add::rec(lam R add => R, self)

def Add::add <A B: Type, self: Add(A, B)>: A -> B -> Add::R(self) :=
    Add::rec(lam R add => add, self)



def Nat::add (a b: Nat): Nat :=
    Nat::rec(a, lam _ r => Nat::succ(r), b)

impl: Add(Nat, Nat) :=
    Add::mk(Nat, Nat::add)

reduce 1 + 2


def quick_maffs: 2 + 2 = 4 := Eq::refl()



def Not (P: Prop): Prop := P -> False


def Eq::symm.{t} <T: Sort(t), a b: T>: a = b -> b = a :=
    lam heq => Eq::rec(Eq::refl(), heq)

def Eq::trans.{t} <T: Sort(t), a b c: T>: a = b -> b = c -> a = c :=
    lam hab hbc => Eq::rec(Eq::rec(Eq::refl(), hab), hbc)


def congr_arg.{a, b} <A: Sort(a), B: Sort(b), a1 a2: A> (f: A -> B)
    : a1 = a2 -> f(a1) = f(a2)
    := lam heq => Eq::rec(Eq::refl(), heq)


def Nat::cases_on.{r} <M: Sort(r)> (n: Nat) (m_zero: M) (m_succ: Pi(n: Nat) -> M): M :=
    Nat::rec(m_zero, lam n _ => m_succ(n), n)


def Nat::No_Confusion.{p} (P: Sort(p), a b: Nat): Sort(p) :=
    Nat::rec(
        Nat::rec(P -> P, lam _ _ => P, a),
        lam b _ => Nat::rec(P, lam a _ => (Eq(a, b) -> P) -> P, a),
        b)

def Nat::no_confusion.{p} <P: Sort(p), a b: Nat>: a = b -> Nat::No_Confusion(P, a, b) :=
    lam h => Eq::rec(Nat::rec(lam p => p, lam _ _ => lam p => p(Eq::refl()), a), h)


def Nat::zero_ne_succ <n: Nat>: Not(Eq(0, Nat::succ(n))) :=
    lam h => Nat::no_confusion(h)


def Nat::succ_inj <a b: Nat>
    : Nat::succ(a) = Nat::succ(b) -> a = b
    := lam h => Nat::no_confusion(h, lam eq => eq)


def Nat::add_zero (n: Nat): n + 0 = n :=
    Eq::refl()

def Nat::zero_add (n: Nat): 0 + n = n :=
    Nat::rec(Eq::refl(), lam n ih => congr_arg(_, ih), n)

-- a.succ + b = (a + b).succ
def Nat::succ_add (a b: Nat)
    : Nat::succ(a) + b = Nat::succ(a + b)
    := Nat::rec(Eq::refl(), lam b ih => congr_arg(_, ih), b)

def Nat::add_comm (a b: Nat): a + b = b + a :=
    Nat::rec(
        Eq::symm(Nat::zero_add(a)),
        lam b ih =>
            Eq::rec(congr_arg(Nat::succ, ih),
                Eq::symm(Nat::succ_add(b, a))),
        b)


def Nat::add_assoc (a b c: Nat): (a + b) + c = a + (b + c)
    := Nat::rec(Eq::refl(), lam c ih => congr_arg(Nat::succ, ih), c)


def Nat::add_left_comm (a b k: Nat): a + (b + k) = b + (a + k)
    := Eq::rec(Eq::rec(Eq::rec(
        Eq::refl(),
        Eq::symm(Nat::add_assoc(b, a, k))),
        Nat::add_comm(b, a)),
        Nat::add_assoc(a, b, k))

def Nat::add_right_comm (a b k: Nat): (k + a) + b = (k + b) + a
    := Eq::rec(Eq::rec(Eq::rec(
        Eq::refl(),
        Nat::add_assoc(k, b, a)),
        Nat::add_comm(b, a)),
        Eq::symm(Nat::add_assoc(k, a, b)))


def Nat::add_left_cancel (a b k: Nat): k + a = k + b -> a = b
    := ax_sorry()

def Nat::add_right_cancel (a b k: Nat): a + k = b + k -> a = b
    := ax_sorry()



def Nat::Le (a b: Nat) := Exists(Nat, lam k => Eq(k + a, b))

def Nat::zero_le (n: Nat): Nat::Le(0, n) := Exists::mk(n, Eq::refl())


def Nat::Lt (a b: Nat) := Nat::Le(Nat::succ(a), b)

def Nat::not_lt_zero (n: Nat): Not(Nat::Lt(n, 0)) :=
    lam hlt => Exists::rec(
        lam k (heq: Nat::add(k, Nat::succ(n)) = 0) =>
            Nat::zero_ne_succ(Eq::symm(heq)),
        hlt)

def Nat::lt_of_succ_lt_succ <a b: Nat>: Nat::Lt(Nat::succ(a), Nat::succ(b)) -> Nat::Lt(a, b) :=
    Exists::rec(
        lam k (h: Nat::add(k, Nat::succ(Nat::succ(a))) = Nat::succ(b)) =>
            Exists::mk(k, Nat::succ_inj(h)))


def Array::nat_sum <n: Nat> (self: Array(Nat, n)): Nat :=
    Array::rec(
        0,
        lam _ head _ res => Nat::add(head, res),
        self)


reduce Array::nat_sum(Array::nil())
reduce Array::nat_sum(Array::cons(1, Array::nil()))
reduce Array::nat_sum(Array::cons(1, Array::cons(2, Array::nil())))
reduce Array::nat_sum(Array::cons(1, Array::cons(2, Array::cons(3, Array::nil()))))


def Array::get <T: Type, n: Nat> (self: Array(T, n), i: Nat, h: Nat::Lt(i, n)): T :=
    Nat::rec(
        lam n self h =>
            Array::rec(
                lam (h: Nat::Lt(0, 0)) =>
                    False::rec(Nat::not_lt_zero(0, h)),
                lam n head tail _ h => head,
                self, h),
        lam i rec n self h =>
            Array::rec(
                lam (h: Nat::Lt(Nat::succ(i), 0)) =>
                    False::rec(Nat::not_lt_zero(Nat::succ(i), h)),
                lam n head tail _ h =>
                    rec(n, tail, Nat::lt_of_succ_lt_succ(h)),
                self, h),
        i, n, self, h)


reduce
    Array::get(
        Array::cons(6, Array::cons(9, Array::nil())),
        0, Exists::mk(1, Eq::refl()))

reduce
    Array::get(
        Array::cons(6, Array::cons(9, Array::nil())),
        1, Exists::mk(0, Eq::refl()))


def scope_approx (a b c n: Nat) :=
    (lam a (b: _ = a, c: Nat, d: a = c) => c)(
        _, Nat::zero_add(_), n, Eq::refl())


def elim_under_applied_1 (a: Nat): Pi(b: Nat) -> Nat :=
    Nat::rec(a, lam _ r => Nat::succ(r))

def elim_under_applied_2: Pi(n: Nat) -> Nat::add(0, n) = n :=
    Nat::rec(Eq::refl(), lam n ih => congr_arg(_, ih))


def double<A: Type, add_impl: Add(A, A)>(a: A): Add::R(add_impl) := a + a


def do_some_doubling(a: Nat): Nat := double(a)

reduce do_some_doubling(3)


inductive Pair(A B: Type) {
    mk (a: A, b: B);
}

def Pair::fst<A B: Type>(p: Pair(A, B)): A :=
    Pair::rec(lam a b => a, p)

def Pair::snd<A B: Type>(p: Pair(A, B)): B :=
    Pair::rec(lam a b => b, p)


impl<A1 A2 B1 B2: Type, add_a: Add(A1, A2), add_b: Add(B1, B2)>:
    Add(Pair(A1, B1), Pair(A2, B2))
    := Add::mk(
        Pair(Add::R(add_a), Add::R(add_b)),
        lam p1 p2 => Pair::mk(
            Pair::fst(p1) + Pair::fst(p2),
            Pair::snd(p1) + Pair::snd(p2)))

impl<A B C: Type, add_a: Add(A, C), add_b: Add(B, C)>:
    Add(Pair(A, B), C)
    := Add::mk(
        Pair(Add::R(add_a), Add::R(add_b)),
        lam p c => Pair::mk(
            Pair::fst(p) + c,
            Pair::snd(p) + c))


reduce 33 + 36
reduce Pair::mk(1, 2) + 3
reduce Pair::mk(3, 3) + Pair::mk(3, 6)

reduce double(7)
reduce double(Pair::mk(1, 2))


def Nat::add_left_comm2 (a b k: Nat): a + (b + k) = b + (a + k) :=
    by {
        goal;
        sorry;
    }

