inductive False: Prop {
}

inductive True: Prop {
    trivial;
}

inductive Nat {
    zero: Nat;
    succ (of: Nat);
}

inductive Eq.{t} <T: Sort(t)> (a: T) : Pi(b: T) -> Prop {
    refl: Eq(a);
}


inductive Array (T: Type) : Pi(n: Nat) -> Type {
    nil: Array(0);
    cons <n: Nat> (head: T, tail: Array(n)): Array(Nat::succ(n));
}


inductive Exists.{t} (T: Sort(t), P: Pi(_: T) -> Prop): Prop {
    mk (value: T, h: P(value))
}

inductive Subtype.{t} <T: Sort(t)> (P: Pi(_: T) -> Prop): Sort(max(1, t)) {
    mk (value: T, h: P(value))
}


def Nat::add (a b: Nat): Nat :=
    Nat::rec(a, lam _ r => Nat::succ(r), b)

reduce Nat::add(1, 2)


def quick_maffs: Eq(Nat::add(2, 2), 4) := Eq::refl()


axiom ax_sorry.{l} (T: Sort(l)): T


def Not (P: Prop): Prop := Pi(_: P) -> False


def Eq::symm.{t} <T: Sort(t), a b: T>: Pi(_: Eq(a, b)) -> Eq(b, a) :=
    lam heq => Eq::rec(Eq::refl(), heq)

def Eq::trans.{t} <T: Sort(t), a b c: T>: Pi(_: Eq(a, b), _: Eq(b, c)) -> Eq(a, c) :=
    lam hab hbc => Eq::rec(Eq::rec(Eq::refl(), hab), hbc)


def congr_arg.{a, b} <A: Sort(a), B: Sort(b), a1 a2: A> (f: Pi(_: A) -> B)
    : Pi (_: Eq(a1, a2)) -> Eq(f(a1), f(a2))
    := lam heq => Eq::rec(Eq::refl(), heq)


def Nat::cases_on.{r} <M: Sort(r)> (n: Nat) (m_zero: M) (m_succ: Pi(n: Nat) -> M): M :=
    Nat::rec(m_zero, lam n _ => m_succ(n), n)


def Nat::No_Confusion.{p} (P: Sort(p), a b: Nat): Sort(p) :=
    Nat::rec(
        Nat::rec(Pi(_: P) -> P, lam _ _ => P, a),
        lam b _ => Nat::rec(P, lam a _ => Pi(_: Pi(_: Eq(a, b)) -> P) -> P, a),
        b)

def Nat::no_confusion.{p} <P: Sort(p), a b: Nat>: Pi(_: Eq(a, b)) -> Nat::No_Confusion(P, a, b) :=
    lam h => Eq::rec(Nat::rec(lam p => p, lam _ _ => lam p => p(Eq::refl()), a), h)


def Nat::zero_ne_succ <n: Nat>: Not(Eq(0, Nat::succ(n))) :=
    lam h => Nat::no_confusion(h)


def Nat::succ_inj <a b: Nat>
    : Pi(_: Eq(Nat::succ(a), Nat::succ(b))) -> Eq(a, b)
    := lam h => Nat::no_confusion(h, lam eq => eq)


def Nat::add_zero (n: Nat): Eq(Nat::add(n, 0), n) :=
    Eq::refl()

def Nat::zero_add (n: Nat): Eq(Nat::add(0, n), n) :=
    Nat::rec(Eq::refl(), lam n ih => congr_arg(_, ih), n)

-- a.succ + b = (a + b).succ
def Nat::succ_add (a b: Nat)
    : Eq(Nat::add(Nat::succ(a), b), Nat::succ(Nat::add(a, b)))
    := Nat::rec(Eq::refl(), lam b ih => congr_arg(_, ih), b)

def Nat::add_comm (a b: Nat): Eq(Nat::add(a, b), Nat::add(b, a)) :=
    Nat::rec(
        Eq::symm(Nat::zero_add(a)),
        lam b ih =>
            Eq::rec(congr_arg(Nat::succ, ih),
                Eq::symm(Nat::succ_add(b, a))),
        b)

def Nat::add_assoc (a b c: Nat)
    : Eq(Nat::add(Nat::add(a, b), c), Nat::add(a, Nat::add(b, c)))
    := Nat::rec(Eq::refl(), lam c ih => congr_arg(Nat::succ, ih), c)


def Nat::add_left_comm (a b k: Nat)
    : Eq(Nat::add(a, Nat::add(b, k)), Nat::add(b, Nat::add(a, k)))
    := Eq::rec(Eq::rec(Eq::rec(
        Eq::refl(),
        Eq::symm(Nat::add_assoc(b, a, k))),
        Nat::add_comm(b, a)),
        Nat::add_assoc(a, b, k))

def Nat::add_right_comm (a b k: Nat)
    : Eq(Nat::add(Nat::add(k, a), b), Nat::add(Nat::add(k, b), a))
    := Eq::rec(Eq::rec(Eq::rec(
        Eq::refl(),
        Nat::add_assoc(k, b, a)),
        Nat::add_comm(b, a)),
        Eq::symm(Nat::add_assoc(k, a, b)))


def Nat::add_left_cancel (a b k: Nat)
    : Pi(_: Eq(Nat::add(k, a), Nat::add(k, b))) -> Eq(a, b)
    := ax_sorry(_)

def Nat::add_right_cancel (a b k: Nat)
    : Pi(_: Eq(Nat::add(a, k), Nat::add(b, k))) -> Eq(a, b)
    := ax_sorry(_)



def Nat::Le (a b: Nat) := Exists(Nat, lam k => Eq(Nat::add(k, a), b))

def Nat::zero_le (n: Nat): Nat::Le(0, n) := Exists::mk(n, Eq::refl())


def Nat::Lt (a b: Nat) := Nat::Le(Nat::succ(a), b)

def Nat::not_lt_zero (n: Nat): Not(Nat::Lt(n, 0)) :=
    lam hlt => Exists::rec(
        lam k (heq: Eq(Nat::add(k, Nat::succ(n)), 0)) =>
            Nat::zero_ne_succ(Eq::symm(heq)),
        hlt)

def Nat::lt_of_succ_lt_succ <a b: Nat>: Pi(_: Nat::Lt(Nat::succ(a), Nat::succ(b))) -> Nat::Lt(a, b) :=
    Exists::rec(
        lam k (h: Eq(Nat::add(k, Nat::succ(Nat::succ(a))), Nat::succ(b))) =>
            Exists::mk(k, Nat::succ_inj(h)))


def Array::nat_sum <n: Nat> (self: Array(Nat, n)): Nat :=
    Array::rec(
        0,
        lam _ head _ res => Nat::add(head, res),
        self)


reduce Array::nat_sum(Array::nil())
reduce Array::nat_sum(Array::cons(1, Array::nil()))
reduce Array::nat_sum(Array::cons(1, Array::cons(2, Array::nil())))
reduce Array::nat_sum(Array::cons(1, Array::cons(2, Array::cons(3, Array::nil()))))


def Array::get <T: Type, n: Nat> (self: Array(T, n), i: Nat, h: Nat::Lt(i, n)): T :=
    Nat::rec(
        lam n self h =>
            Array::rec(
                lam (h: Nat::Lt(0, 0)) =>
                    False::rec(Nat::not_lt_zero(0, h)),
                lam n head tail _ h => head,
                self, h),
        lam i rec n self h =>
            Array::rec(
                lam (h: Nat::Lt(Nat::succ(i), 0)) =>
                    False::rec(Nat::not_lt_zero(Nat::succ(i), h)),
                lam n head tail _ h =>
                    rec(n, tail, Nat::lt_of_succ_lt_succ(h)),
                self, h),
        i, n, self, h)


reduce
    Array::get(
        Array::cons(6, Array::cons(9, Array::nil())),
        0, Exists::mk(1, Eq::refl()))

reduce
    Array::get(
        Array::cons(6, Array::cons(9, Array::nil())),
        1, Exists::mk(0, Eq::refl()))


def scope_approx (a b c n: Nat) :=
    (lam a (b: Eq(_, a), c: Nat, d: Eq(a, c)) => c)(
        _, Nat::zero_add(_), n, Eq::refl())


def elim_under_applied_1 (a: Nat): Pi(b: Nat) -> Nat :=
    Nat::rec(a, lam _ r => Nat::succ(r))

def elim_under_applied_2: Pi(n: Nat) -> Eq(Nat::add(0, n), n) :=
    Nat::rec(Eq::refl(), lam n ih => congr_arg(_, ih))


trait inductive Add (A B: Type) {
    mk (R: Type) (add: Pi(_: A, _: B) -> R)
}

def Add::R <A B: Type> (self: Add(A, B)): Type :=
    Add::rec(lam R add => R, self)

def Add::add <A B: Type> (self: Add(A, B)): Pi(_: A, _: B) -> Add::R(self) :=
    Add::rec(lam R add => add, self)


def double<A: Type, add: Add(A, A)>(a: A): Add::R(add) :=
    Add::add(add)(a, a)


impl: Add(Nat, Nat) := Add::mk(Nat, Nat::add)

def do_some_doubling(a: Nat): Nat :=
    double(a)


